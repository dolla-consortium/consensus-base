-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Optional function arguments
--   
--   This library provides a type for specifying <a>Optional</a> function
--   arguments
--   
--   Read the tutorial in <a>Data.Optional</a> to learn more
@package optional-args
@version 1.0.2


-- | Use the <a>Optional</a> type for optional function arguments. For
--   example:
--   
--   <pre>
--   import Data.Optional
--   
--   greet :: Optional String -&gt; String
--   greet (Specific name) = "Hello, " ++ name
--   greet  Default        = "Hello"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; greet (Specific "John")
--   "Hello, John"
--   
--   &gt;&gt;&gt; greet Default
--   "Hello"
--   </pre>
--   
--   The <a>Optional</a> type overloads as many Haskell literals as
--   possible so that you do not need to wrap values in <a>Specific</a>.
--   For example, if you enable the <tt>OverloadedStrings</tt> extension
--   you can use a naked string literal instead:
--   
--   <pre>
--   &gt;&gt;&gt; :set -XOverloadedStrings
--   
--   &gt;&gt;&gt; greet "John"
--   "Hello, John"
--   </pre>
--   
--   The <a>Optional</a> type also implements <a>Num</a> and
--   <a>Fractional</a>, so you can use numeric literals in place of
--   <a>Optional</a> values:
--   
--   <pre>
--   birthday :: Optional Int -&gt; String
--   birthday (Specific age) = "You are " ++ show age ++ " years old!"
--   birthday  Default       = "You are one year older!"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; birthday 20
--   "You are 20 years old!"
--   
--   &gt;&gt;&gt; birthday Default
--   "You are one year older!"
--   </pre>
--   
--   The <a>IsString</a>, <a>Num</a>, and <a>Fractional</a> instances are
--   recursive, so you can wrap your types in a more descriptive newtype
--   and derive <a>IsString</a>, <a>Num</a> or <a>Fractional</a>:
--   
--   <pre>
--   {-# LANGUAGE GeneralizedNewtypeDeriving #-}
--   
--   import Data.Optional
--   import Data.String (IsString)
--   
--   newtype Name = Name { getName :: String } deriving (IsString)
--   
--   greet :: Optional Name -&gt; String
--   greet (Specific name) = "Hello, " ++ getName name
--   greet  Default        = "Hello"
--   
--   newtype Age = Age { getAge :: Int } deriving (Num)
--   
--   birthday :: Optional Age -&gt; String
--   birthday (Specific age) = "You are " ++ show (getAge age) ++ " years old!"
--   birthday  Default       = "You are one year older!"
--   </pre>
--   
--   ... and you would still be able to provide naked numeric or string
--   literals:
--   
--   <pre>
--   &gt;&gt;&gt; :set -XOverloadedStrings
--   
--   &gt;&gt;&gt; greet "John"
--   "Hello, John"
--   
--   &gt;&gt;&gt; birthday 20
--   "You are 20 years old!"
--   </pre>
--   
--   You can use <a>empty</a> as a short-hand for a <a>Default</a>
--   argument:
--   
--   <pre>
--   &gt;&gt;&gt; greet empty
--   "Hello"
--   
--   &gt;&gt;&gt; birthday empty
--   "You are one year older!"
--   </pre>
--   
--   You can also use <a>pure</a> as a short-hand for a <a>Specific</a>
--   argument:
--   
--   <pre>
--   &gt;&gt;&gt; greet (pure "John")
--   "Hello, John"
--   
--   &gt;&gt;&gt; birthday (pure 20)
--   "You are 20 years old!"
--   </pre>
module Data.Optional

-- | A function argument that has a <a>Default</a> value
data Optional a
Default :: Optional a
Specific :: a -> Optional a

-- | The <a>defaultTo</a> function takes a default value and an
--   <a>Optional</a> value. If the <a>Optional</a> is <a>Default</a>, it
--   returns the default value; otherwise, it returns the value contained
--   in the <a>Optional</a>.
defaultTo :: a -> Optional a -> a

-- | Convert an <a>Optional</a> value into an instance of
--   <a>Alternative</a>.
fromOptional :: Alternative f => Optional a -> f a

-- | The <a>optional</a> function takes a default value, a function, and an
--   <a>Optional</a> value. If the <a>Optional</a> value is <a>Default</a>,
--   the function returns the default value. Otherwise, it applies the
--   function to the value inside the <a>Optional</a> and returns the
--   result.
optional :: b -> (a -> b) -> Optional a -> b

-- | The identity of <a>&lt;|&gt;</a>
empty :: Alternative f => f a

-- | Lift a value.
pure :: Applicative f => a -> f a
instance GHC.Show.Show a => GHC.Show.Show (Data.Optional.Optional a)
instance Data.Traversable.Traversable Data.Optional.Optional
instance Data.Foldable.Foldable Data.Optional.Optional
instance GHC.Base.Functor Data.Optional.Optional
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Optional.Optional a)
instance GHC.Base.Applicative Data.Optional.Optional
instance GHC.Base.Monad Data.Optional.Optional
instance GHC.Base.Alternative Data.Optional.Optional
instance GHC.Base.MonadPlus Data.Optional.Optional
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (Data.Optional.Optional a)
instance GHC.Base.Monoid a => GHC.Base.Monoid (Data.Optional.Optional a)
instance Data.String.IsString a => Data.String.IsString (Data.Optional.Optional a)
instance GHC.Num.Num a => GHC.Num.Num (Data.Optional.Optional a)
instance GHC.Real.Fractional a => GHC.Real.Fractional (Data.Optional.Optional a)
